extern crate alloc;

use alloc::string::String;
use alloc::vec::Vec;

use core::{
    fmt::{self, Debug},
    str::FromStr,
};
use rand_core::{CryptoRng, RngCore};
use secrecy::{ExposeSecret, SecretString, Zeroize};
use serde::{Deserialize, Serialize};
use subtle::ConstantTimeEq;

use juicebox_sdk_marshalling::{bytes, serialize_secret};

#[derive(Clone, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct SecretBytesArray<const N: usize>(#[serde(with = "bytes")] [u8; N]);

impl<const N: usize> Zeroize for SecretBytesArray<N> {
    fn zeroize(&mut self) {
        self.0.zeroize();
    }
}

impl<const N: usize> Drop for SecretBytesArray<N> {
    fn drop(&mut self) {
        self.zeroize();
    }
}

impl<const N: usize> Debug for SecretBytesArray<N> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str("SecretBytesArray(REDACTED)")
    }
}

impl<const N: usize> ExposeSecret<[u8; N]> for SecretBytesArray<N> {
    fn expose_secret(&self) -> &[u8; N] {
        &self.0
    }
}

impl<const N: usize> From<[u8; N]> for SecretBytesArray<N> {
    fn from(value: [u8; N]) -> Self {
        Self(value)
    }
}

impl<const N: usize> TryFrom<Vec<u8>> for SecretBytesArray<N> {
    type Error = &'static str;

    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
        Ok(Self(
            TryInto::<[u8; N]>::try_into(value).map_err(|_| "incorrectly sized secret array")?,
        ))
    }
}

#[derive(Clone, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct SecretBytesVec(#[serde(with = "bytes")] Vec<u8>);

impl Zeroize for SecretBytesVec {
    fn zeroize(&mut self) {
        self.0.zeroize();
    }
}

impl Drop for SecretBytesVec {
    fn drop(&mut self) {
        self.zeroize();
    }
}

impl Debug for SecretBytesVec {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str("SecretBytesVec(REDACTED)")
    }
}

impl ExposeSecret<Vec<u8>> for SecretBytesVec {
    fn expose_secret(&self) -> &Vec<u8> {
        &self.0
    }
}

impl From<Vec<u8>> for SecretBytesVec {
    fn from(value: Vec<u8>) -> Self {
        Self(value)
    }
}

pub type OprfCipherSuite = voprf::Ristretto255;
pub type OprfBlindedElement = voprf::BlindedElement<OprfCipherSuite>;
pub type OprfEvaluationElement = voprf::EvaluationElement<OprfCipherSuite>;
pub type OprfClient = voprf::OprfClient<OprfCipherSuite>;
pub type OprfServer = voprf::OprfServer<OprfCipherSuite>;
pub type OprfHash = digest::Output<<OprfCipherSuite as voprf::CipherSuite>::Hash>;
pub const OPRF_KEY_INFO: &[u8] = b"juicebox-oprf";

#[derive(Debug)]
pub struct OprfResult(SecretBytesArray<64>);

impl From<OprfHash> for OprfResult {
    fn from(value: OprfHash) -> Self {
        Self(SecretBytesArray(Into::<[u8; 64]>::into(value)))
    }
}

impl OprfResult {
    pub fn expose_secret(&self) -> &[u8] {
        self.0.expose_secret()
    }
}

#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct OprfBlindedInput(SecretBytesArray<32>);

impl From<OprfBlindedElement> for OprfBlindedInput {
    fn from(value: OprfBlindedElement) -> Self {
        Self(SecretBytesArray::from(Into::<[u8; 32]>::into(
            value.serialize(),
        )))
    }
}

impl From<[u8; 32]> for OprfBlindedInput {
    fn from(value: [u8; 32]) -> Self {
        Self(SecretBytesArray::from(value))
    }
}

impl OprfBlindedInput {
    pub fn expose_secret(&self) -> OprfBlindedElement {
        OprfBlindedElement::deserialize(self.0.expose_secret()).expect("invalid blinded element")
    }
}

#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct OprfBlindedResult(SecretBytesArray<32>);

impl From<OprfEvaluationElement> for OprfBlindedResult {
    fn from(value: OprfEvaluationElement) -> Self {
        Self(SecretBytesArray::from(Into::<[u8; 32]>::into(
            value.serialize(),
        )))
    }
}

impl From<[u8; 32]> for OprfBlindedResult {
    fn from(value: [u8; 32]) -> Self {
        Self(SecretBytesArray::from(value))
    }
}

impl OprfBlindedResult {
    pub fn expose_secret(&self) -> OprfEvaluationElement {
        OprfEvaluationElement::deserialize(self.0.expose_secret())
            .expect("invalid evaluation element")
    }
}

/// A private oprf seed generated by the client.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct OprfSeed(SecretBytesArray<32>);

impl OprfSeed {
    /// Generates a new oprf seed with random data.
    pub fn new_random<T: RngCore + CryptoRng + Send>(rng: &mut T) -> Self {
        let mut seed = [0; 32];
        rng.fill_bytes(&mut seed);
        Self::from(seed)
    }

    pub fn expose_secret(&self) -> &[u8] {
        self.0.expose_secret()
    }
}

impl From<[u8; 32]> for OprfSeed {
    fn from(value: [u8; 32]) -> Self {
        Self(SecretBytesArray::from(value))
    }
}

/// A unique identifier for a realm.
///
/// A realm is a remote service that clients interact with to register and
/// recover their PIN-protected secrets. Clients distribute their trust across
/// multiple realms, which can run different software and hardware and can be
/// operated independently.
#[derive(Copy, Clone, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct RealmId(#[serde(with = "bytes")] pub [u8; 16]);

impl Debug for RealmId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        for byte in self.0 {
            write!(f, "{byte:02x}")?;
        }
        Ok(())
    }
}

impl FromStr for RealmId {
    type Err = &'static str;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let vec = hex::decode(s.replace('-', "")).map_err(|_| "failed to decode hex id")?;
        Ok(Self(vec.try_into().map_err(|_| "invalid id length")?))
    }
}

/// Represents the authority to act as a particular user.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AuthToken(#[serde(serialize_with = "serialize_secret")] pub SecretString);

impl AuthToken {
    pub fn expose_secret(&self) -> &str {
        self.0.expose_secret()
    }
}

impl From<SecretString> for AuthToken {
    fn from(value: SecretString) -> Self {
        AuthToken(value)
    }
}

impl From<String> for AuthToken {
    fn from(value: String) -> Self {
        AuthToken(SecretString::from(value))
    }
}

/// A unique version used to determine if different realms represent the
/// same registration.
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct RegistrationVersion(SecretBytesArray<16>);

impl RegistrationVersion {
    /// Generates a new version with random data.
    pub fn new_random<T: RngCore + CryptoRng + Send>(rng: &mut T) -> Self {
        let mut version = [0; 16];
        rng.fill_bytes(&mut version);
        Self::from(version)
    }

    pub fn expose_secret(&self) -> &[u8] {
        self.0.expose_secret()
    }
}

impl From<[u8; 16]> for RegistrationVersion {
    fn from(value: [u8; 16]) -> Self {
        Self(SecretBytesArray::from(value))
    }
}

/// Used for hashing `Pin`s with Argon2.
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct Salt(SecretBytesArray<16>);

impl Salt {
    /// Generates a new salt with random data.
    pub fn new_random<T: RngCore + CryptoRng + Send>(rng: &mut T) -> Self {
        let mut salt = [0; 16];
        rng.fill_bytes(&mut salt);
        Self::from(salt)
    }

    pub fn expose_secret(&self) -> &[u8] {
        self.0.expose_secret()
    }
}

impl From<[u8; 16]> for Salt {
    fn from(value: [u8; 16]) -> Self {
        Self(SecretBytesArray::from(value))
    }
}

impl TryFrom<Vec<u8>> for Salt {
    type Error = &'static str;

    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
        Ok(Self(SecretBytesArray::try_from(value)?))
    }
}

/// A share of the [`Salt`].
///
/// The client needs a threshold number of such shares to recover the salt.
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct SaltShare(SecretBytesArray<17>);

impl SaltShare {
    pub fn expose_secret(&self) -> &[u8] {
        self.0.expose_secret()
    }
}

impl From<[u8; 17]> for SaltShare {
    fn from(value: [u8; 17]) -> Self {
        Self(SecretBytesArray::from(value))
    }
}

impl TryFrom<Vec<u8>> for SaltShare {
    type Error = &'static str;

    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
        Ok(Self(SecretBytesArray::try_from(value)?))
    }
}

/// Used to distinguish different secure communication channels for a single
/// user.
///
/// This is useful in case a user has multiple concurrent Noise sessions (from
/// one or more clients). The IDs are opaque and are chosen randomly by the
/// client. If the chosen IDs collide, the user might see extra errors and have
/// to retry, but that's the worst that should happen. Session IDs need not be
/// confidential.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct SessionId(pub u32);

/// A share of the user's secret.
///
/// The client needs a threshold number of such shares to recover the user's
/// secret.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct UserSecretShare(SecretBytesArray<146>);

impl UserSecretShare {
    /// Access the underlying secret bytes.
    pub fn expose_secret(&self) -> &[u8] {
        self.0.expose_secret()
    }
}

impl TryFrom<Vec<u8>> for UserSecretShare {
    type Error = &'static str;

    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
        Ok(Self(SecretBytesArray::try_from(value)?))
    }
}

/// Defines restrictions on how a secret may be accessed.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct Policy {
    /// The number of guesses allowed before the secret can no longer be
    /// accessed.
    ///
    /// This should be set to a small number greater than 0. Lower numbers have
    /// a smaller risk that an adversary could guess the PIN to unlock the
    /// secret, but they have a larger risk that the user will get accidentally
    /// locked out due to typos and transient errors.
    pub num_guesses: u16,
}

/// A share of the unlock key that has been XORed with `OPRF(PIN)`.
///
/// The client sends this to a realm during registration and gets it back from
/// the realm during recovery.
///
/// The client needs the correct PIN and a threshold number of such shares and
/// OPRF results to recover the unlock key.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct MaskedUnlockKeyShare(SecretBytesArray<33>);

impl MaskedUnlockKeyShare {
    pub fn expose_secret(&self) -> &[u8] {
        self.0.expose_secret()
    }
}

impl TryFrom<Vec<u8>> for MaskedUnlockKeyShare {
    type Error = &'static str;

    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
        Ok(Self(SecretBytesArray::try_from(value)?))
    }
}

/// A pseudo-random value that the client assigns to a realm when registering a
/// share of the user's secret and must provide to the realm during recovery to
/// get back the share.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct UnlockTag(SecretBytesArray<32>);

impl ConstantTimeEq for UnlockTag {
    fn ct_eq(&self, other: &Self) -> subtle::Choice {
        self.expose_secret().ct_eq(other.expose_secret())
    }
}

impl UnlockTag {
    pub fn expose_secret(&self) -> &[u8] {
        self.0.expose_secret()
    }
}

impl From<[u8; 32]> for UnlockTag {
    fn from(value: [u8; 32]) -> Self {
        Self(SecretBytesArray::from(value))
    }
}

#[cfg(test)]
mod tests {
    use crate::types::{SecretBytesArray, SecretBytesVec};
    use secrecy::Zeroize;

    #[test]
    fn test_secret_byte_vec_redaction() {
        let secret_bytes = SecretBytesVec::from(b"some secret".to_vec());
        assert_eq!(format!("{:?}", secret_bytes), "SecretBytesVec(REDACTED)");
    }

    #[test]
    fn test_secret_byte_vec_zeroize() {
        let mut secret_bytes = SecretBytesVec::from(b"some secret".to_vec());
        secret_bytes.zeroize();
        assert_eq!(secret_bytes, SecretBytesVec::from(vec![]));
    }

    #[test]
    fn test_secret_byte_array_redaction() {
        let secret_bytes = SecretBytesArray::from([5; 32]);
        assert_eq!(format!("{:?}", secret_bytes), "SecretBytesArray(REDACTED)");
    }

    #[test]
    fn test_secret_byte_array_zeroize() {
        let mut secret_bytes = SecretBytesArray::from([5; 32]);
        secret_bytes.zeroize();
        assert_eq!(secret_bytes, SecretBytesArray::from([0; 32]));
    }
}
